import sys
import os
import shutil
import getpass, time, json
import pvsimple as pvs
from .commonfunction import LoadingMessage
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication, QDialog,QFrame
from PyQt5.QtWidgets import QApplication,QFileDialog
from PyQt5 import uic
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import QDir
from PyQt5.Qt import *
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot
from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow, QTreeWidget
from .commonfunction import *
from .Workspace.workspace_ui import Ui_Workspace
from .post import (ResultFile, PlotWindow,
            ColorRep, WarpRep, ModesRep, BaseRep,
            pvcontrol, show_min_max, selection_probe, selection_plot,
            get_active_selection, get_pv_mem_use, dbg_print,
            RESULTS_PV_LAYOUT_NAME, RESULTS_PV_VIEW_NAME)
from .post.navigator import OverlayBar
from ..pyqtgraph.widgets.GraphicsLayoutWidget import GraphicsLayoutWidget
from .Residual_error.ResidualplotUi import Ui_Residual_plot
# from meshview.baseview import MeshBaseView
from PyQt5 import uic
from .Tree.tree import TreeWidget
from .Email.emailAlert import send
import sip
import math
from functools import reduce

class Workspace_tool(QWidget):
    def __init__(self, astergui, parent=None):
        super(Workspace_tool,self).__init__()

        self.astergui = astergui
        model = turbulence_model = wall_function = ''

        # self.ui = Ui_Workspace()
        self.ui = uic.loadUi('/usr/sw-cluster/simforge/WINDSIM/SALOME9.4/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/demo2.ui')

        # self.ui.setupUi(self)
        v_layout = QtWidgets.QVBoxLayout(self)
        v_layout.setContentsMargins(0, 0, 0, 0)
        v_layout.addWidget(self.ui)


class Workspace(QWidget):
    '''
    workspace实际上是嵌入salome最顶层的窗口
    '''
    _loader = res_splitter = pv_widget = pv_view = pv_layout = None
    ren_view = pv_overlay = toolbuttons = current = previous = None
    pv_widget_children = play_btn = pause_btn = outline_btn = None
    minmax_btn = infobar_label = shown = filename_label = None
    set_workingdir = pyqtSignal(str)
    def __init__(self, astergui, parent=None):
        super(Workspace,self).__init__()
        self.pv_view = None
        self.workdir = ''
        self.geoPath = None
        self.jsonfile = ''
        self.res = self.ren_view = self.default_file_root = None
        self.astergui = astergui
        self.previous = {}
        self.receiver = '739509208@qq.com'
        # pimplefoam_root 是default文件alternative文件的上层文件夹，其中文件是用来配置openfoam的
        self.pimplefoam_root = '/home/leo/Documents/Salome-9.4/SALOME-9.4.0-UB18.04-SRC/BINARIES-UB18.04/ASTERSTUDY/lib/python3.6/site-packages/asterstudy'
        # 主窗口为横向布局，并添加了分割器
        self.horizontalLayout = QtWidgets.QHBoxLayout(self)
        self.main_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal, self)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                           QtWidgets.QSizePolicy.Expanding)
        self.main_splitter.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                        QtWidgets.QSizePolicy.Expanding)
        self.horizontalLayout.addWidget(self.main_splitter)  
        # self.work_space_tool是主窗口左边标签页区域
        # self.work_space_tool = Workspace_tool(astergui)

        self.ui = uic.loadUi('/usr/sw-cluster/simforge/WINDSIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/windsim.ui')
        # self.matui = uic.loadUi('/usr/sw-cluster/simforge/ICESIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/mat.ui')
        # self.ui.pushButton_mat.clicked.connect(self.showmat)
        # self.ui.pushButton_matcheck.clicked.connect(self.matCheck)
        # self.ui.lineEdit_3.setEnabled(False)
        self.ui.toolButton.clicked.connect(lambda:self.getGeoPath(self.ui.blade))
        self.ui.toolButton_2.clicked.connect(lambda:self.getGeoPath(self.ui.cabin))
        self.ui.toolButton_3.clicked.connect(lambda:self.getGeoPath(self.ui.tower))
        self.ui.toolButton_4.clicked.connect(lambda:self.getGeoPath(self.ui.hub))

        self.process = QtCore.QProcess(self)
        self.ui.pushButton_new.clicked.connect(self.creatProject)
        # self.ui.pushButton.clicked.connect(self.getCasPath)
        

        self.ui.pushButton_sub.clicked.connect(self.handleCalc)
        self.ui.pushButton_transfer.clicked.connect(lambda:self.ui.tabWidget.setEnabled(False))
        self.ui.pushButton_transfer.clicked.connect(self.handleTrans)
        # self.ui.pushButton_showmesh.clicked.connect(self.show_mesh)


        self.main_splitter.addWidget(self.ui)
        # self.right_container是主窗口右侧区域其中包含了paraview窗口和日志显示停靠窗口,由self.pv_splitter实现上下分割
        ## 增加paraview窗口
        self.right_container = QtWidgets.QWidget()
        self.right_container.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                QtWidgets.QSizePolicy.Expanding)
        self.right_container_layout = QtWidgets.QHBoxLayout(self.right_container)
        self.main_splitter.addWidget(self.right_container)
        self.pv_splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical, self.right_container)
        self.pv_splitter.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                        QtWidgets.QSizePolicy.Expanding) 
        self.right_container_layout.addWidget(self.pv_splitter)
        ## 初始化paraview窗口
        self.init_paraview()
        # 增加日志显示窗口(后又增加计算进度显示，所以整个停靠窗口用tab widget布局)
        self.log_widget = QtWidgets.QDockWidget(self.right_container)
        self.log_widget_Contents = QtWidgets.QWidget()
        self.log_widget_layout = QtWidgets.QHBoxLayout(self.log_widget_Contents)
        self.log_tab_widget = QtWidgets.QTabWidget(self.log_widget_Contents)
        self.log_tab = QtWidgets.QWidget()
        self.progress_tab = QtWidgets.QWidget()
        self.log_tab_Layout = QtWidgets.QHBoxLayout(self.log_tab)
        self.progress_tab_Layout = QtWidgets.QVBoxLayout(self.progress_tab)
        self.log_textBrowser = QtWidgets.QTextBrowser(self.log_widget_Contents)
        self.log_textBrowser.setReadOnly(True)
        self.log_tab_Layout.addWidget(self.log_textBrowser)
        self.log_tab_widget.addTab(self.log_tab,'日志')
        self.log_tab_widget.addTab(self.progress_tab,'残差')
        ### 计算进度显示(由两部分组成，残差图和进度条)
        self.residual_plot_widget = QtWidgets.QWidget()
        self.residual_plot = Ui_Residual_plot()
        self.residual_plot.setupUi(self.residual_plot_widget)
        self.progress_tab_Layout.addWidget(self.residual_plot_widget)

        self.progress_bar_Layout=QtWidgets.QHBoxLayout()
        self.pushButton_stop = QtWidgets.QPushButton()
        self.pushButton_stop.setMinimumSize(QtCore.QSize(0, 0))
        self.pushButton_stop.setObjectName("pushButton_stop")
        self.pushButton_stop.setText('STOP')
        self.progress_bar_Layout.addWidget(self.pushButton_stop)
        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setProperty("value", 0)
        self.progress_bar.setValue(0)
        self.progress_bar_Layout.addWidget(self.progress_bar)
        self.progress_bar_label = QtWidgets.QLabel('预计还剩: s')
        self.progress_bar_label.setText('预计还剩: 10s')
        self.progress_bar_Layout.addWidget(self.progress_bar_label)
        self.progress_tab_Layout.addLayout(self.progress_bar_Layout)
      
        self.log_widget_layout.addWidget(self.log_tab_widget)
        self.log_widget.setWidget(self.log_widget_Contents)
        self.pv_splitter.addWidget(self.log_widget)
        titleBar=QWidget()
        self.log_widget.setTitleBarWidget(titleBar)
        ## 调整paraview和日志显示的初始上下显示比例
        self.main_splitter.setStretchFactor(0,2)
        self.main_splitter.setStretchFactor(1,8)
        # 切换前处理、计算、后处理
        self.ui.tabWidget.currentChanged['int'].connect(self.main_tab_change)
        # 打开工程
        self.ui.pushButton_open.clicked.connect(self.reload)
        # 中止
        self.pushButton_stop.clicked.connect(self.terminate_self)
        # self.disable_some_buttons()
        self.ui.cbox_queue.currentTextChanged.connect(self.check_queue)
        self.ui.label_21.setMinimumSize(QtCore.QSize(0, 0))

    def showmat(self):
        #初始化
        self.matui = uic.loadUi('/usr/sw-cluster/simforge/WINDSIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/mat.ui')

        with open(self.jsonfile,"r") as f:
            self.infodic = json.load(f)
            moldata = {}
            for key in self.infodic['materials']:
                if self.infodic['materials'][key].__contains__('molecular-weight') and self.infodic['materials'][key]['type'] == 'solid':
                    moldata[key] = self.infodic['materials'][key]['molecular-weight']
            # print(moldata)


        for i, key in zip(range(len(moldata)), moldata):
            self.mat1 =QtWidgets.QLabel(key)
            self.key = QtWidgets.QLineEdit()
            self.key.setPlaceholderText(moldata[key])
            self.matui.gridLayout.addWidget(self.mat1,i,0)
            self.matui.gridLayout.addWidget(self.key,i,1)
        self.matui.show()
        self.matui.buttonBox.accepted.connect(self.save_info)
        
    def save_info(self):
        # print(self.matui.gridLayout.rowCount())
        for i in range(self.matui.gridLayout.rowCount()):
            if self.matui.gridLayout.itemAtPosition(i, 1).widget().__class__.__name__ == 'QLineEdit':
                value = self.matui.gridLayout.itemAtPosition(i, 1).widget().text()
                matname = self.matui.gridLayout.itemAtPosition(i, 0).widget().text()
                if not value == '':
                    self.infodic['materials'][matname]['molecular-weight'] = value
                # print(matname, value, type(value))
        with open(self.jsonfile,"w") as f:
            json.dump(self.infodic, f, indent = 4, ensure_ascii = False)

    def matCheck(self):
        self.matcheckui = uic.loadUi('/usr/sw-cluster/simforge/WINDSIM/SALOME9.4/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/mat.ui')
        self.win = TreeWidget(self.jsonfile)
        self.matcheckui.gridLayout.addWidget(self.win)
        self.matcheckui.show()

    def getGeoPath(self, objectName):
        if self.geoPath:
            self.cwd = os.path.dirname(self.geoPath)
        else:
            self.cwd = os.path.join(os.environ['HOME'], 'WORK')
        self.geoPath = self.get_file_name('.stl')
        objectName.setText(self.geoPath)
        os.system('cp ' + self.geoPath +' ' + os.path.join(self.workdir,'constant','triSurface'))

        self.process.start('echo cas源文件：'+self.workdir+'已导入')
        self.process.waitForFinished()


    def handleTrans(self):
        
        self.hub_ctx = self.ui.hub_ctx.text()
        self.hub_cty = self.ui.hub_cty.text()
        self.hub_ctz = self.ui.hub_ctz.text()

        self.wt_radius = self.ui.wt_radius.text()
        self.bd_prebend = self.ui.bd_prebend.text()
        self.overhang = self.ui.overhang.text()
        self.tower_h = self.ui.tower_h.text()

        self.queue = self.ui.cbox_queue.currentText()
        self.cores = self.ui.cbox_cores.currentText()
        print(self.queue, self.cores)

        # self.hub_ctx = '0'
        # self.hub_cty = '0'
        # self.hub_ctz = '0'

        # self.wt_radius = '2.25'
        # self.bd_prebend = '0.8'
        # self.overhang = '2.25'
        # self.tower_h = '5.5'





        self.blade = os.path.basename(self.ui.blade.text())
        self.cabin = os.path.basename(self.ui.cabin.text())
        self.tower = os.path.basename(self.ui.tower.text())
        self.hub   = os.path.basename(self.ui.hub.text())

        parame = {'hub_ctx':self.hub_ctx,'hub_cty':self.hub_cty,'hub_ctz':self.hub_ctz,
                  'wt_radius':self.wt_radius,'bd_prebend':self.bd_prebend,
                  'overhang':self.overhang,'tower_h':self.tower_h,
                  'geometry':
                      {
                              'blade':self.blade,'cabin':self.cabin,
                              'tower':self.tower,'hub':self.hub
                      },
                'queue':self.queue, 'cores':self.cores
             }
        print(str(parame))
        print(self.workdir, self.geoPath, self.hub_ctx, self.hub_cty, self.hub_ctz, self.wt_radius,  self.bd_prebend, self.overhang ,self.tower_h)
        # try:
        #     for value in parame:
        #         if self.is_dict(value):
        #             for element in value:
        #                 if element == '':
        #                     QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
        #                     self.ui.tabWidget.setEnabled(True)
        #                     return
        # except:
        #     QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
        #     self.ui.tabWidget.setEnabled(True)
        #     return
        try:
            for value in parame.values():
                print(value)
                if self.is_dict(value):
                    for element in value.values():
                        print(element)
                        if element == '' or value == None:
                            print('kong')
                            QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
                            self.ui.tabWidget.setEnabled(True)
                            return
                else:
                    if value == '' or value == None:
                        QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
                        self.ui.tabWidget.setEnabled(True)
                        return
        except:
            QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
            self.ui.tabWidget.setEnabled(True)
            return
        # print('return is',aa )
        #Save case infomation
        infodic = {}
        infodic['status'] = 'running'
        infodic['anthor'] = getpass.getuser()
        infodic['projectpath'] = self.workdir
        infodic['parame'] = parame
        infodic['startTime'] = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) 
        
        self.projectname = self.workdir.split('/')[-1]

        #生成案例的json文件
        self.jsonfile = os.path.join(self.workdir, self.projectname+'.json')
        print(self.jsonfile)
        # if not os.path.exists(jsonfile):
        #     # os.rmdir(jsonfile)
        with open(self.jsonfile,"w") as f:
            json.dump(infodic, f, indent=4)


        cmd ='/opt/skyformai/bin/csub  -I -A WindTurbine -Jd WindTurbine_transfer/' + self.projectname
        cmd += ' -n '+self.cores
        cmd += ' -q '+self.queue
        cmd += ' -cwd '+self.workdir
        cmd += (' /usr/sw-cluster/simforge/WINDSIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/Python/bin/python3 '
                +'/usr/sw-cluster/simforge/WINDSIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/wp/mesh-WTSim.py '
                + self.workdir +' '+ str(parame))

        try:
            # self.process.finished.connect(self.show_generated_mesh)  #一直循环执行
            # self.process.readyRead.connect(self.dataReady)
            # self.process.setProcessChannelMode(QProcess.MergedChannels)
            self.process.readyReadStandardOutput.connect(self.dataReady)
            # self.process.finished.connect(self.show_generated_mesh)
            self.process.start(cmd)
            QtWidgets.QMessageBox.information(self, '网格转化中', '网格转化中，请稍后')
            # self.ui.tabWidget.setEnabled(1,False)
            # self.process.waitForFinished()
            # self.show_generated_mesh()
            print('网格转换完成')
            self.ui.tabWidget.setEnabled(False)
            self.process.start('echo 网格转换中……')
            # self.process.waitForFinished()
            # self.process.finished.connect(lambda:self.settab(True))
            self.process.finished.connect(self.settab)
            # self.process.finished.connect(self.enable_some_buttons)
            # self.process.waitForFinished()
            # self.process.finished[int, QProcess.ExitStatus].connect(self.show_mesh)
            

        except Exception as e:
            print(e)

    def is_dict(self,value):
        if isinstance(value, dict):
            print('is dict')
            return True
        elif isinstance(value, str):
            print('is str')
            return False
        else:
            return False

    def parames_check(self, parames):
        try:
            for value in parames.values():
                print(value)
                if self.is_dict(value):
                    for element in value.values():
                        print(element)
                        if element == '' or value == None:
                            print('kong')
                            QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
                            self.ui.tabWidget.setEnabled(True)
                            return
                else:
                    if value == '' or value == None:
                        QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
                        self.ui.tabWidget.setEnabled(True)
                        return
        except:
            QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
            self.ui.tabWidget.setEnabled(True)
            return



    def check_queue(self):
        self.queue = self.ui.cbox_queue.currentText()
        cores_remain = int(os.popen('/home/export/online3/amd_share/shangruan/bin/qparse '+ self.queue).read())
        self.ui.label_21.setText(str(cores_remain))
        print(cores_remain)

    def handleCalc(self):

        self.hub_ctx = self.ui.hub_ctx.text()
        self.hub_cty = self.ui.hub_cty.text()
        self.hub_ctz = self.ui.hub_ctz.text()
        self.wt_radius = self.ui.wt_radius.text()
        self.queue = self.ui.cbox_queue.currentText()
        self.cores = self.ui.cbox_cores.currentText()

        self.speedx = self.ui.lineEdit_x.text()
        self.speedy = self.ui.lineEdit_y.text()
        self.speedz = self.ui.lineEdit_z.text()
        self.windspeed = " ".join(i for i in [self.speedx, self.speedy, self.speedz])
        self.rotatespeed = self.ui.lineEdit_rotatespeed.text()
        self.pressure = self.ui.lineEdit_pressure.text()
        self.density = self.ui.lineEdit_density.text()
        self.nu = self.ui.lineEdit_nu.text()
        self.maxiters = self.ui.lineEdit_maxint.text()
        self.InputInterval = self.ui.lineEdit_output.text()
        self.receiver = self.ui.lineEdit_4.text()
        # self.receiver = '739509208@qq.com'
        # print(self.workdir, self.casPath, self.queue, self.cores, self.maxiters, self.InputInterval, self.receiver)
        

        parame_cal = {'speedx':self.speedx,'speedy':self.speedy,'speedz':self.speedz,'windspeed':self.windspeed,'atm':self.pressure,'rho':self.density,'nu':self.nu,
              'hub_ctx':self.hub_ctx,'hub_cty':self.hub_cty,'hub_ctz':self.hub_ctz,'wt_radius':self.wt_radius,
              'writestep':self.InputInterval,'runtime':self.maxiters,'rpm':self.rotatespeed,'para_num':self.cores,'queue':self.queue}

        print(str(parame_cal))

        # self.parames_check(parame_cal)

        for element in parame_cal.values():
            if element == '':
                QtWidgets.QMessageBox.information(self, 'Warning', '参数不能为空')
                return

        infodic = {}
        with open (self.jsonfile,"r+", encoding='utf-8') as f:
            infodic = json.load(f)
        infodic['status'] = 'running'
        infodic['anthor'] = getpass.getuser()
        infodic['cores']  = self.cores
        infodic['queue']  = self.queue
        infodic['parame_cal'] = parame_cal
        infodic['projectpath'] = self.workdir
        infodic['iterations'] = self.maxiters
        infodic['recordInterval'] = self.InputInterval
        infodic['subTime'] = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) 
        # print(self.jsonfile)
        # if not os.path.exists(jsonfile):
        #     # os.rmdir(jsonfile)
        with open(self.jsonfile,"w+") as f:
            json.dump(infodic, f, indent=4)


        cmd ='/opt/skyformai/bin/csub  -I -A WindTurbine -Jd WindTurbine_solver/' + self.projectname
        cmd += ' -n '+self.cores
        cmd += ' -q '+self.queue
        cmd += ' -cwd '+self.workdir

        cmd += (' /usr/sw-cluster/simforge/WINDSIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/Python/bin/python3 '
                +'/usr/sw-cluster/simforge/WINDSIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/wp/fluidinitial.py '
                + self.workdir +' '+ '"'+str(parame_cal)+'"')

        try:
            # self.process.finished.connect(self.show_generated_mesh)  #一直循环执行
            # self.process.readyRead.connect(self.dataReady)
            # self.process.setProcessChannelMode(QProcess.MergedChannels)
            self.process.readyReadStandardOutput.connect(self.dataReady)
            # self.process.finished.connect(self.show_generated_mesh)
            self.process.start(cmd)
            QtWidgets.QMessageBox.information(self, '提交成功', '可至云平台查看作业状态')

            self.ui.tabWidget.setEnabled(False)
            self.pushButton_stop.setEnabled(True)
            self.progress_bar.setValue(0)  
            # self.process.waitForFinished()
            # self.show_generated_mesh()
            self.resdatapath = os.path.join(self.workdir, 'postProcessing/residuals/0/residuals.dat')
            self.logpath = os.path.join(self.workdir,'log')
            if os.path.exists(self.resdatapath):
                os.remove(self.resdatapath)
            if os.path.exists(self.logpath):
                os.remove(self.logpath)
           
            import _thread
            try:
                _thread.start_new_thread(self.residual_plotting, ("Thread-1", 3, ))
            except:
                print ("Error: 无法启动线程")  
            # self.show_generated_mesh()
            print(' end submit')
        except Exception as e:
            print(e)

    def settab(self, exitCode,  exitStatus):
        self.ui.tabWidget.setEnabled(True)
        # self.show_mesh()

    def creatProject(self):
        self.cwd = os.path.join(os.environ['HOME'], 'WORK')
        self.workdir = self.get_dir_name()
        self.ui.lineEdit_2.setText(self.workdir)
        sourcedir = '/usr/sw-cluster/simforge/WINDSIM/SALOME-9.4.0-CO7-SRC/BINARIES-CO7/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/wp/sourceDir/.'
        os.system('cp  -r ' + sourcedir +' ' + self.workdir)

        self.fname = os.path.join(self.workdir, os.path.basename(self.workdir)+'.foam')

        self.process.start('echo 工程目录已创建:'+self.workdir)
        self.process.waitForFinished()

    def get_file_name(self,filetype):
        fname, filetype = QFileDialog.getOpenFileName(self,  
                                    "选取文件",  
                                    self.cwd, # 起始路径 
                                    "All Files (*);;OpenFoam Files (*" + filetype + ")")
        return fname

    def get_dir_name(self):
        dir_choose = QFileDialog.getExistingDirectory(self,  
                                    "选取文件夹",  
                                    self.cwd) # 起始路径
        return dir_choose 

#     def continue_to_calculate(self):
#         changefile(self.workingdirectory+'/system/controlDict','startFrom','latestTime')
#         self.disable_some_buttons()
#         self.process.start('sh '+ self.workingdirectory + '/run.sh '+ self.workingdirectory)
#         self.work_space_tool.ui.pushButton_12.clicked.connect(self.terminate_self)
#         self.process.waitForFinished()
#         self.programError()
#         self.process.finished.connect(self.enable_some_buttons)
#         self.log_textBrowser.moveCursor(self.log_textBrowser.textCursor().End)
        
    def enable_some_buttons(self):
        self.ui.pushButton_mat.setEnabled(True)
        self.ui.pushButton_matcheck.setEnabled(True)
        self.ui.pushButton_showmesh.setEnabled(True)
#         self.work_space_tool.ui.pushButton_5.setEnabled(True)
#         self.work_space_tool.ui.pushButton_6.setEnabled(True)
#         self.work_space_tool.ui.pushButton_7.setEnabled(True)
#         self.work_space_tool.ui.pushButton_8.setEnabled(True)
#         self.work_space_tool.ui.pushButton_9.setEnabled(True)
#         self.work_space_tool.ui.pushButton_10.setEnabled(True)
#         self.work_space_tool.ui.pushButton_11.setEnabled(True)
#         self.work_space_tool.ui.pushButton_13.setEnabled(True)
#         self.work_space_tool.computing_control.groupBox.setEnabled(True)
#         self.work_space_tool.ui.pushButton_12.setEnabled(False)
#         self.work_space_tool.ui.tabWidget.setTabEnabled(0,True)
#         self.work_space_tool.ui.tabWidget.setTabEnabled(2,True)

    def disable_some_buttons(self):
        self.ui.pushButton_mat.setEnabled(False)
        self.ui.pushButton_matcheck.setEnabled(False)
        self.ui.pushButton_showmesh.setEnabled(False)
#         self.work_space_tool.ui.pushButton_5.setEnabled(False)
#         self.work_space_tool.ui.pushButton_6.setEnabled(False)
#         self.work_space_tool.ui.pushButton_7.setEnabled(False)
#         self.work_space_tool.ui.pushButton_8.setEnabled(False)
#         self.work_space_tool.ui.pushButton_9.setEnabled(False)
#         self.work_space_tool.ui.pushButton_10.setEnabled(False)
#         self.work_space_tool.ui.pushButton_11.setEnabled(False)
#         self.work_space_tool.ui.pushButton_13.setEnabled(False)
#         self.work_space_tool.computing_control.groupBox.setEnabled(False)
#         self.work_space_tool.ui.pushButton_12.setEnabled(True)
#         self.work_space_tool.ui.tabWidget.setTabEnabled(0,False)
#         self.work_space_tool.ui.tabWidget.setTabEnabled(2,False)

    def terminate_self(self):
        # 中止计算进程
        try:
            self.process.kill()
            command = "cat log | grep '^Job' | cut -d' ' -f2 "
            content = os.popen(command)
            self.jobids = content.read().strip().split('\n')
            content.close()
            self.jobid = str(int(self.jobids[-1].strip().replace('<','').replace('>','')))
            # self.process.start('env -i /usr/sw-mpp/bin/bkill  '+ self.jobid)
            os.popen('env -i /usr/sw-mpp/bin/bkill  '+ self.jobid)
            QtWidgets.QMessageBox.information(self, 'tip', '作业'+self.jobid+'已取消')
            print(self.jobid)
            self.process.start('echo 作业已取消')
            self.pushButton_stop.setEnabled(False)
            self.ui.tabWidget.setEnabled(True)
            # import _thread
            # _thread.exit() #引起了sys.exit()
        except Exception as e:
            print(e)

#     def reload(self):
#         import json
#         # cwd为打开文件的默认路径
#         self.cwd = '/home/leo/Documents/Salome-9.4/SALOME-9.4.0-UB18.04-SRC/BINARIES-UB18.04/ASTERSTUDY/lib/python3.6/site-packages/asterstudy'
#         # 读取文件夹名
#         filedir = self.get_dir_name()
#         if filedir:
#             self.workingdirectory = filedir
#             #根据所打开文件夹中的project_data.json初始化页面
#             with open(self.workingdirectory + '/project_data.json','r') as load_f:
#                 load_dict = json.load(load_f)       
#             self.update_workingdir_for_dialogs(self.workingdirectory)
#             self.show_mesh(self.workingdirectory + '/.foam')
#             self.dialogs_reload(self.workingdirectory,load_dict)
#             self.process.start('echo 已打开工程，工程目录：'+self.workingdirectory)
#             self.process.waitForFinished()

#     # 初始化各个弹窗
#     def dialogs_reload(self,workingdirectory,dictionary):
#         if 'material' in dictionary.keys():
#             self.work_space_tool.mat_man.reload(dictionary)

#         # 初始化model模块时要把model相关的弹窗一并初始化
#         if 'model' in dictionary.keys():
#             self.work_space_tool.mod_man.reload(dictionary,self.work_space_tool.mod_man)
#             model = self.work_space_tool.mod_man.comboBox.currentText()
#             wall_function = ''
#             if model == 'laminar':
#                 turbulence_model = 'laminar' 
#             else:
#                 turbulence_model = self.work_space_tool.mod_man.formLayout.itemAt(1,1).widget().currentText()
#                 wall_function = self.work_space_tool.mod_man.addcombobox_2.currentText()
#             self.update_dialog_by_model(model,turbulence_model,wall_function)
#             self.update_dialog_by_model_and_boundary(model,turbulence_model,wall_function)

#         if 'boundaryconditions' in dictionary.keys():
#             self.work_space_tool.bod_man.reload(dictionary)  

#         if 'field' in dictionary.keys():
#             self.work_space_tool.fie_man.reload(dictionary,self.work_space_tool.fie_man)  

#         if 'scheme' in dictionary.keys():
#             self.work_space_tool.sch_man.reload(dictionary) 

#         if 'solver' in dictionary.keys():
#             self.work_space_tool.sol_man.reload(dictionary) 

#         if 'compute_control' in dictionary.keys():
#             self.work_space_tool.computing_control.reload(dictionary) 
  
#     def start_computing(self):
#         self.disable_some_buttons()
#         # self.process.start('echo 开始计算')
#         # self.process.waitForFinished()
#         run_sh_default = self.pimplefoam_root + "/gui/Run/run.sh"
#         run_sh_working_dir = [self.workingdirectory + '/run.sh']
#         #复制run脚本文件到工程目录并修改
#         initfile(run_sh_working_dir[0],run_sh_default)
#         # changefile4(run_sh_working_dir[0],'cd',self.workingdirectory)
#         #放到系统中后需要改?
#         # os.system('dos2unix ' +run_sh_working_dir[0])
#         # self.process.waitForFinished()
#         self.process.start('sh '+ self.workingdirectory + '/run.sh '+ self.workingdirectory)
#         self.work_space_tool.ui.pushButton_12.clicked.connect(self.terminate_self)
#         #画残差图
#         # import _thread
#         # try:
#         #     _thread.start_new_thread(self.residual_plotting, ("Thread-1", 5, ))
#         # except:
#         #     print ("Error: 无法启动线程")   
#         # self.process.start('echo 计算已完成，请打开后处理标签页查看结果')
#         self.process.waitForFinished()
#         self.programError()
#         self.process.finished.connect(self.enable_some_buttons)
#         self.log_textBrowser.moveCursor(self.log_textBrowser.textCursor().End)

    def residual_plotting(self,threadName, delay):
        import time, csv
        from datetime import datetime, timedelta
        os.chdir(self.workdir)
        # 抓取运算时间，用于推测预计剩余时间
        command3 = "cat log | grep 'ExecutionTime' | cut -d' ' -f3 | tail -n 2"
        command4 = "cat log | grep '^Time' | cut -d' ' -f3 |tail -n 1"
        command5 = "cat log | grep 'ClockTime' | cut -d' ' -f8 |tail -n 2"
        # 抓取End关键词，用于判断计算是否结束
        command6 = "cat log | grep 'End' | cut -d' ' -f3 |tail -n 1"
        while True:
            try:
                time.sleep(delay)
                self.resdatapath = os.path.join(self.workdir, 'postProcessing/residuals/0/residuals.dat')
                print(self.resdatapath)
                fieldlist = ['p','Ux','Uy','Uz']
                # plotdata = []
                datadic = {}
                for field in fieldlist:
                    datadic[field] = []
                try:
                    with open(self.resdatapath) as f:
                        reader = csv.reader(f, delimiter="\t")
                        print(self.resdatapath)
                        for line in reader:
                            # print(line)
                            try:
                                # if isinstance(eval(line[0].strip()),int):
                                if line[0].strip() != '# Residuals' and line[0].strip() != '# Time':
                                    for i, field in zip(range(1,7),fieldlist):
                                        datadic[field].append(math.log10(eval(line[i].strip())))
                            except:
                                pass
                except:
                    pass
                if os.path.exists(os.path.join(self.workdir,'log')):
                    content3 = os.popen(command3)
                    delta_exacuate_time_list = content3.read().strip().split('\n')
                    content3.close()
                    content4 = os.popen(command4)
                    computed_time_list = content4.read().strip().split('\n')
                    content4.close()
                    content5 = os.popen(command5)
                    deltaT_list = content5.read().strip().split('\n')
                    content5.close()

                    total_time = float(self.maxiters)
                    print('total time:')
                    print(total_time)
                    print('computed_time_list:')
                    print(computed_time_list)
                    print('deltaT_list:')
                    print(deltaT_list)
                    computed_time =  float(computed_time_list[0])
                    delta_exacuate_time = float(deltaT_list[-1]) - float(deltaT_list[0])
                    # delta_exacuate_time = float(delta_exacuate_time_list[1])-float(delta_exacuate_time_list[0])

                    epxected_remaining_time = int((total_time-computed_time)/1e-7*delta_exacuate_time)
                    prograss_bar_value = int(computed_time/total_time*100)
                    self.progress_bar.setValue(prograss_bar_value)   
                    sec = timedelta(seconds=epxected_remaining_time)
                    d = datetime(1,1,1) + sec
                    if epxected_remaining_time < 60:
                        self.progress_bar_label.setText('预计还剩:' + "%d秒" % d.second)
                    elif epxected_remaining_time < 3600:
                        self.progress_bar_label.setText('预计还剩:' + "%d分%d秒" % ( d.minute, d.second))
                    elif epxected_remaining_time < 86400:
                        self.progress_bar_label.setText('预计还剩:' + "%d时%d分%d秒" % ( d.hour, d.minute, d.second))
                    elif epxected_remaining_time > 86400:
                        self.progress_bar_label.setText('预计还剩:' + "%d天%d时%d分%d秒" % (d.day-1, d.hour, d.minute, d.second))    
                    content6 = os.popen(command6)
                    is_over_list = content6.read().strip().split('\n')
                    content6.close()
                    is_over = is_over_list[0]
                    if is_over:
                        self.progress_bar.setValue(100)
                        # self.ui.tabWidget.setEnabled(True)
                        # break# print(datadic)
                if os.path.exists(self.resdatapath):

                    for i, key in zip(range(4), datadic):
                        # print(i, key)
                        self.residual_plot.curve_list[i].setData(datadic[key])
                        # print(self.residual_plot.curve_list[i])

                    if len(datadic['p']) >= eval(self.maxiters) and is_over:
                        try:
                            self.ui.tabWidget.setEnabled(True)
                            self.pushButton_stop.setEnabled(False)
                            break
                        except Exception as e:
                            print(e)
                    pass
                                
            except Exception as e:
                print(e)
                print('fail to plot residual error')

    
    def main_tab_change(self,index):
        '''
            前处理，计算，后处理标签点击触发的函数
            index = 1 代表计算
            index = 2 代表后处理
        '''
        print(index)
        if index == 1:
            if not self.workdir:
                QtWidgets.QMessageBox.information(self, '错误', '请先设置工程目录!')
        if index == 2:
            import SalomePyQt
            import pvsimple as pvs
            sg = SalomePyQt.SalomePyQt()
            current_view = sg.getViews()
            self.detach()
            sg.activateModule("ParaViS")
            views = sg.getViews()
            print(views)
            sg.setViewTitle(views[-1],'ParaViS')
            self.ui.tabWidget.setCurrentIndex(0)
            aaa = pvs.GetActiveSource()
            pvs.Delete(aaa)
            

            #### disable automatic camera reset on 'Show'
            pvs._DisableFirstRenderCameraReset()

            # create a new 'OpenFOAMReader'
            foam = pvs.OpenFOAMReader(FileName=self.fname)
            
            # get animation scene
            animationScene1 = pvs.GetAnimationScene()

            # timeKeeper1 = GetTimeKeeper()

            # update animation scene based on data timesteps
            animationScene1.UpdateAnimationUsingDataTimeSteps()

            # set active source
            pvs.SetActiveSource(foam)

            # get active view
            renderView1 = pvs.GetActiveViewOrCreate('RenderView')
            # uncomment following to set a specific view size
            # renderView1.ViewSize = [1054, 491]

            # show data in view
            foamDisplay = pvs.Show(foam, renderView1)

            # trace defaults for the display properties.
            foamDisplay.Representation = 'Surface'

            # show color bar/color legend
            foamDisplay.SetScalarBarVisibility(renderView1, True)

            # reset view to fit data
            renderView1.ResetCamera()

            # get color transfer function/color map for 'p'
            pLUT = pvs.GetColorTransferFunction('p')

            # get opacity transfer function/opacity map for 'p'
            pPWF = pvs.GetOpacityTransferFunction('p')  

            if os.path.exists(self.workdir + '/processor0'):
                print('1111111')
                foam.CaseType = 'Decomposed Case'
                animationScene1.UpdateAnimationUsingDataTimeSteps()
                renderView1.Update()
 

    def dataReady(self):
        '''
            监听Qprocess进程的日志输出，如果有输出，则触发此函数将日输出到前端
        '''
        # logOutput = self.log_textBrowser.textCursor()
        processStdout = bytearray(self.process.readAllStandardOutput())
        processStdout = processStdout.decode(encoding='UTF-8',errors='strict')

        newCursor1 = self.log_textBrowser.textCursor()
        newCursor1.movePosition(QtGui.QTextCursor.End)
        self.log_textBrowser.setTextCursor(newCursor1)
        logOutput = self.log_textBrowser.textCursor()
        logOutput.insertText(processStdout)
        # self.log_textBrowser.moveCursor(self.log_textBrowser.textCursor().End)

    def reload(self):
        import json
        self.cwd = os.path.join(os.environ['HOME'], 'WORK')
        # 读取文件夹名
        filedir = self.get_dir_name()
        if filedir:
            self.workdir = filedir
            self.jsonfile = os.path.join(self.workdir, os.path.basename(self.workdir)+'.json')
            self.projectname = self.workdir.split('/')[-1]
            #根据所打开文件夹中的project_data.json初始化页面
            with open(self.jsonfile,'r') as load_f:
                infodic = json.load(load_f)

            self.loadinfo(infodic)
            # self.enable_some_buttons()       
            # self.update_workingdir_for_dialogs(self.workingdirectory)
            self.show_mesh()
            # self.dialogs_reload(self.workingdirectory,load_dict)
            self.process.start('echo 已打开工程，工程目录：'+self.workdir)
            self.process.waitForFinished()

    def loadinfo(self,infodic):
        # self.casPath = infodic['caspath']
        self.casname = os.path.basename(self.workdir)
        self.ui.lineEdit_2.setText(self.workdir)
        self.ui.blade.setText(infodic['parame']['geometry']['blade'])
        self.ui.cabin.setText(infodic['parame']['geometry']['cabin'])
        self.ui.tower.setText(infodic['parame']['geometry']['tower'])
        self.ui.hub.setText(infodic['parame']['geometry']['hub'])
        self.ui.hub_ctx.setText(infodic['parame']['hub_ctx'])
        self.ui.hub_cty.setText(infodic['parame']['hub_cty'])
        self.ui.hub_ctz.setText(infodic['parame']['hub_ctz'])
        self.ui.wt_radius.setText(infodic['parame']['wt_radius'])
        self.ui.bd_prebend.setText(infodic['parame']['bd_prebend'])
        self.ui.overhang.setText(infodic['parame']['overhang'])
        self.ui.tower_h.setText(infodic['parame']['tower_h'])
        self.ui.cbox_queue.setCurrentText(infodic['parame']['queue'])
        self.ui.cbox_cores.setCurrentText(infodic['parame']['cores'])
        if 'parame_cal' in infodic and os.path.exists(self.workdir + '/processor0'):
            self.queue = infodic['queue']
            self.cores = infodic['cores']
            self.maxiters = infodic['iterations']
            self.InputInterval = infodic['recordInterval']
            self.ui.lineEdit_x.setText(infodic['parame_cal']['speedx'])
            self.ui.lineEdit_y.setText(infodic['parame_cal']['speedy'])
            self.ui.lineEdit_z.setText(infodic['parame_cal']['speedz'])
            self.ui.lineEdit_rotatespeed.setText(infodic['parame_cal']['rpm'])
            self.ui.lineEdit_pressure.setText(infodic['parame_cal']['atm'])
            self.ui.lineEdit_density.setText(infodic['parame_cal']['rho'])
            self.ui.lineEdit_nu.setText(infodic['parame_cal']['nu'])
            self.ui.lineEdit_maxint.setText(self.maxiters)
            self.ui.lineEdit_output.setText(self.InputInterval)
            
            import _thread
            try:
                _thread.start_new_thread(self.residual_plotting, ("Thread-2", 1,))
            except:
                print ("Error: 无法启动线程")
        try:
            with open(os.path.join(self.workdir,'log'),'r+') as f:
                print('reading...')
                log = f.readlines() 
                # self.log_textBrowser.setText(reduce(lambda x, y: x+y, log))
                self.log_textBrowser.setText("".join(log))
                self.log_textBrowser.moveCursor(self.log_textBrowser.textCursor().End)
                print('log print is ok')
        except Exception as e:
            print(e)

#     def programError(self):
#         '''
#             监听Qprocess进程的日志输出，如果有输出，则触发此函数将日输出到前端
#         '''
#         processStdout = bytearray(self.process.readAllStandardError())
#         processStdout2= processStdout.decode(encoding='UTF-8',errors='strict')
#         newCursor1 = self.log_textBrowser.textCursor()
#         newCursor1.movePosition(QtGui.QTextCursor.End)
#         self.log_textBrowser.setTextCursor(newCursor1)
#         logOutput = self.log_textBrowser.textCursor()
#         logOutput.insertText(processStdout2)
#         # self.log_textBrowser.moveCursor(self.log_textBrowser.textCursor().End)

#     def show_mesh_display_list(self,boundary_root):
#         '''
#             展示网格显示处的internal part和各边界的列表
#             boundary_root为工程路径中的constant/polyMesh/boundary
#         '''
#         self.mesh_list = []
#         with open(boundary_root,'r+',encoding='utf-8') as fr:
#             keywordlist = fr.read().splitlines()
#             for index,text in enumerate(keywordlist):
#                 if text == '    {':
#                     self.mesh_list.append(keywordlist[index-1].lstrip('    '))                 
#         fr.close()

#         self.internalMesh_region = QtWidgets.QCheckBox()
#         self.internalMesh_region.setText('internalMesh')
#         self.internalMesh_region.setChecked(True)
#         self.work_space_tool.ui.formLayout.addWidget(self.internalMesh_region)
#         for items in self.mesh_list:
#             self.mesh_region = QtWidgets.QCheckBox()
#             self.mesh_region.setText(items)
#             self.work_space_tool.ui.formLayout.addWidget(self.mesh_region)

#     def change_mesh_display(self, res):
#         '''
#             改变网格显示的区域及方法
#             res为pvs.OpenFOAMReader读取.foam文件后生成的对象
#         '''
#         res_MeshRegions = []
#         if res:
#             for i in range(self.work_space_tool.ui.formLayout.rowCount()):
#                 if self.work_space_tool.ui.formLayout.itemAt(i,1).widget().isChecked():
#                     items = self.work_space_tool.ui.formLayout.itemAt(i,1).widget().text()
#                     res_MeshRegions.append(items)
#             res.MeshRegions = res_MeshRegions
#             self.ren_view = pvs.GetRenderView()
#             represent_type = self.work_space_tool.ui.represent_combo.currentText()
#             self.currentdisplay.SetRepresentationType(represent_type)
#             self.ren_view.Update()
#             # The following two lines insure that the view is refreshed
#             self.pv_splitter.setVisible(False)
#             self.pv_splitter.setVisible(True)
#         else:
#             pass

#     def check_is_working_dir_mesh_tran(self):
#         '''
#             判断工程目录是否已经被设置
#         '''
#         if self.workingdirectory:
#             self.work_space_tool.MeshtranDialog.show()
#             self.work_space_tool.mesh_tran.pushButton_3.clicked.connect(self.work_space_tool.MeshtranDialog.reject)
#         else:
#             QtWidgets.QMessageBox.information(self, '错误', '请先设置工程目录!')

#     def check_is_working_dir_gen_mesh(self):
#         '''
#             判断工程目录是否已经被设置
#         '''
#         if self.workingdirectory:
#             self.work_space_tool.MeshgenerateDialog.show()
#         else:
#             QtWidgets.QMessageBox.information(self, '错误', '请先设置工程目录!')

    def show_generated_mesh(self):
        '''
            通过openfoam命令生成网格
        '''
        # self.process.start('echo 开始生成blockMesh...')
        # self.process.waitForFinished()
        # mesh_generate_sh_default = self.pimplefoam_root + "/gui/Mesh_generation/mesh_generate.sh"
        # mesh_generate_sh_working_dir = [self.workingdirectory + '/mesh_generate.sh']
        # initfile(mesh_generate_sh_working_dir[0],mesh_generate_sh_default)
        # changefile4(mesh_generate_sh_working_dir[0],'cd',self.workingdirectory)
        # #放到系统中后需要改?
        # self.process.start('dos2unix ' +mesh_generate_sh_working_dir[0])
        # self.process.waitForFinished()
        # self.process.start('sh '+ mesh_generate_sh_working_dir[0])
        # self.process.waitForFinished()
        self.fname = os.path.join(self.workdir, self.casname.replace('cas','foam'))
        self.show_mesh(self.fname)

    def show_mesh(self):
        '''
            显示网格
        '''
        # boundary_file = self.workingdirectory + '/constant/polyMesh/boundary'
        # self.process.start('echo 开始显示网格...')
        # self.process.waitForFinished()
        # self.show_mesh_display_list(boundary_file)
        try:
            if self.currentdisplay:
                aaa = pvs.GetActiveSource()
                pvs.Delete(aaa)
                print('delete ok')
        except Exception as e:
            print(e)
            pass

        try:
            self.fname = os.path.join(self.workdir, self.casname.replace('cas','foam'))
            self.res = pvs.OpenFOAMReader(FileName=self.fname)
            print(self.fname)
            self.ren_view = pvs.GetRenderView()
            self.foamDisplay = pvs.Show(self.res, self.ren_view)
            self.currentdisplay = self.foamDisplay
            self.currentdisplay.Opacity = 0.8
            # The following two lines insure that the view is refreshed
            self.pv_splitter.setVisible(False)
            self.pv_splitter.setVisible(True)
            print('网格已显示')
            self.process.start('echo 网格已显示')
            self.ui.pushButton_showmesh.setEnabled(False)
        except Exception as e:
            print(e)
        # self.process.waitForFinished()
        # boundary_file_root = self.workingdirectory + '/constant/polyMesh/boundary'
        # self.work_space_tool.BCDialog = QDialog()
        # self.work_space_tool.bod_man = Ui_boundary_form()
        # self.work_space_tool.bod_man.setupUi(self.work_space_tool.BCDialog,self.workingdirectory,self.pimplefoam_root, boundary_file_root)
        # self.work_space_tool.mod_man.Model_selecting.connect(self.update_dialog_by_model_and_boundary)

#     def show_mesh_check_res(self):
#         '''
#             网格检查功能
#         '''
#         self.process.start('echo 开始检查网格')
#         self.process.waitForFinished()
#         mesh_check_sh_default = self.pimplefoam_root + "/gui/Checkmesh/mesh_check.sh"
#         mesh_check_sh_working_dir = [self.workingdirectory + '/mesh_check.sh']
#         initfile(mesh_check_sh_working_dir[0],mesh_check_sh_default)
#         changefile4(mesh_check_sh_working_dir[0],'cd',self.workingdirectory)
#         #放到系统中后需要改?
#         self.process.start('dos2unix ' +mesh_check_sh_working_dir[0])
#         self.process.waitForFinished()
#         self.process.start('sh '+ mesh_check_sh_working_dir[0])
#         self.process.waitForFinished()

#     def return_to_smash(self):
#         pass

#     def transfer_mash(self, workingdirectory):
#         '''
#             unv格式转化为foam
#             workingdirectory是工程路径
#         '''
#         self.cwd = '/home/leo/Documents/Salome-9.4/SALOME-9.4.0-UB18.04-SRC/BINARIES-UB18.04/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/test'
#         full_load_pv=True
#         # self.shown = None
#         unv_file = self.get_file_name('.unv')
#         if unv_file:
#             unv_fname = os.path.basename(unv_file)
#             self.work_space_tool.MeshtranDialog.accept()

#             if workingdirectory:
#                 unv_dir_file = self.workingdirectory + '/' + unv_fname
#                 initfile(unv_dir_file, unv_file)
#                 self.process.start('echo 开始转化...')
#                 self.process.waitForFinished()
#                 #放到系统中后需要改
#                 mesh_tran_sh_default =self.pimplefoam_root + "/gui/Mesh_transfer/mesh_transfer.sh"
#                 mesh_tran_sh_working_dir = [self.workingdirectory + '/mesh_transfer.sh']
#                 initfile(mesh_tran_sh_working_dir[0],mesh_tran_sh_default)
#                 changefile4(mesh_tran_sh_working_dir[0],'cd',self.workingdirectory)
#                 changefile4(mesh_tran_sh_working_dir[0],'ideasUnvToFoam',unv_fname)
#                 #放到系统中后需要改?
#                 self.process.start('dos2unix ' +mesh_tran_sh_working_dir[0])
#                 self.process.waitForFinished()
#                 self.process.start('sh '+ mesh_tran_sh_working_dir[0])
#                 self.process.waitForFinished()
#                 self.process.start('echo 转化完成')
#                 self.process.waitForFinished()
#                 fname = workingdirectory + '/' + '.foam'
#                 self.show_mesh(fname)
  
#             else:
  
#                 QtWidgets.QMessageBox.information(self, '错误', '请先设置工程目录!')
#         else:
#             pass


#     def create_dir(self):
#         '''
#             创建工程路径
#         '''
#         import salome
#         # home_dir = str(os.system("echo $HOME"))
#         home_dir = os.popen('echo $HOME').read()
#         print(home_dir)
#         self.default_file_root = self.pimplefoam_root + '/defaultfile'
#         self.cwd = home_dir
#         filedir = self.get_dir_name()
#         if filedir:
#             self.set_workingdir.emit(filedir)
#             filedir += '/workingdirectory'
#             inittree(filedir,self.default_file_root)
#             self.workingdirectory = filedir
#             self.update_workingdir_for_dialogs(self.workingdirectory)
#             self.process.start('echo 已创建工程，工程目录：'+self.workingdirectory)
#             self.process.waitForFinished()
#         else:
#             pass
        
#     def get_file_name(self,filetype):
#         fname, filetype = QFileDialog.getOpenFileName(self,  
#                                     "选取文件",  
#                                     self.cwd, # 起始路径 
#                                     "All Files (*);;OpenFoam Files (*" + filetype + ")")
#         return fname

#     def get_dir_name(self):
#         dir_choose = QFileDialog.getExistingDirectory(self,  
#                                     "选取文件夹",  
#                                     self.cwd) # 起始路径
#         return dir_choose

#     def open_openfoam_file(self,workingdirectory):
#         '''
#             打开foam，初始化工程文件夹
#         '''
#         if workingdirectory:
#             self.cwd = '/home/leo/Documents/Salome-9.4/SALOME-9.4.0-UB18.04-SRC/BINARIES-UB18.04/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/test/pimpleFoam/laminar/pitzDailyPulse'
#             full_load_pv = True
#             #######
#             filedir = self.get_dir_name()
#             fname = workingdirectory + '/' + '.foam'
#             if not os.path.isfile(fname):  # 无文件时创建
#                 fd = open(fname, mode="w", encoding="utf-8")
#                 fd.close()
#             if filedir:
#                 # default_file_root = os.path.dirname(fname)
#                 inittree(workingdirectory + '/constant/polyMesh',filedir)
                
#                 self.show_mesh(fname)

#             else:
#                 pass 
#         else:
#             QtWidgets.QMessageBox.information(self, '错误', '请先设置工程目录')

#     def update_workingdir_for_dialogs(self, workingdirectory):
#         '''
#             实际作用为更新各个弹窗的工程路径信息
#         '''
#         self.work_space_tool.MaterialDialog = QDialog() 
#         self.work_space_tool.mat_man = Ui_Mat_Man(workingdirectory,self.pimplefoam_root)
#         self.work_space_tool.mat_man.setupUi(self.work_space_tool.MaterialDialog)
#         self.work_space_tool.MaterialDialog.setWindowModality(Qt.ApplicationModal)
#         self.work_space_tool.mat_man.subDialog.setWindowModality(Qt.ApplicationModal)

#         self.work_space_tool.ModelDialog = QDialog()
#         self.work_space_tool.mod_man = Ui_Mod_Edi()
#         self.work_space_tool.mod_man.setupUi(self.work_space_tool.ModelDialog,workingdirectory,self.pimplefoam_root)
#         self.work_space_tool.mod_man.Model_selecting.connect(self.update_dialog_by_model)

#         self.work_space_tool.BCDialog = QDialog()
#         self.work_space_tool.bod_man = Ui_boundary_form()
#         self.work_space_tool.bod_man.setupUi(self.work_space_tool.BCDialog,workingdirectory,self.pimplefoam_root)

#         self.work_space_tool.FieldDialog = QDialog()
#         self.work_space_tool.fie_man = Ui_Fieldsetting()
#         self.work_space_tool.fie_man.setupUi(self.work_space_tool.FieldDialog,workingdirectory,self.pimplefoam_root)

#         self.work_space_tool.SolverDialog = QDialog()
#         self.work_space_tool.sol_man = Ui_Sol_Man()
#         self.work_space_tool.sol_man.setupUi(self.work_space_tool.SolverDialog,workingdirectory)

#         self.work_space_tool.SchemeDialog = QDialog()
#         self.work_space_tool.sch_man = Ui_Schemesetting()
#         self.work_space_tool.sch_man.setupUi(self.work_space_tool.SchemeDialog,workingdirectory)

#         self.work_space_tool.MeshtranDialog = QDialog()
#         self.work_space_tool.mesh_tran = Ui_Mesh_tran()
#         self.work_space_tool.mesh_tran.setupUi(self.work_space_tool.MeshtranDialog)
#         self.work_space_tool.MeshtranDialog.setWindowModality(Qt.ApplicationModal)
#         self.work_space_tool.mesh_tran.pushButton.clicked.connect(self.return_to_smash)
#         self.work_space_tool.mesh_tran.pushButton_2.clicked.connect(lambda:self.transfer_mash(self.workingdirectory))

#         self.work_space_tool.MeshgenerateDialog = QDialog()
#         self.work_space_tool.mesh_generate = Ui_Mesh_generate()
#         self.work_space_tool.mesh_generate.setupUi(self.work_space_tool.MeshgenerateDialog,workingdirectory,self.pimplefoam_root)
#         self.work_space_tool.MeshgenerateDialog.setWindowModality(Qt.ApplicationModal)
#         self.work_space_tool.mesh_generate.ok_button.clicked.connect(self.show_generated_mesh)
        
#         self.work_space_tool.ComputingControlDialog = QDialog()
#         self.work_space_tool.computing_control = Ui_Computing_control()
#         self.work_space_tool.computing_control.setupUi(self.work_space_tool.ComputingControlDialog, workingdirectory,self.pimplefoam_root)

#     def update_dialog_by_model_and_boundary(self,model,turbulence_model,wall_function):
#         '''
#             实际作用为更新相关弹窗的湍流模型设置和boundary文件路径信息
#             model:laminar,RAS,LES
#             turbulence_model: e.g.kEpsilon,kOmegaSST
#             wall_function: on or off
#         '''
#         self.model = model
#         self.turbulence_model = turbulence_model
#         self.wall_function = wall_function

#         boundary_file_root = self.workingdirectory + '/constant/polyMesh/boundary'
#         self.work_space_tool.BCDialog = QDialog()
#         self.work_space_tool.bod_man = Ui_boundary_form(model = self.model,turbulence_model = self.turbulence_model)
#         self.work_space_tool.bod_man.setupUi(self.work_space_tool.BCDialog,self.workingdirectory,self.pimplefoam_root, boundary_file_root)

#         # self.work_space_tool.FieldDialog = QDialog()
#         # self.work_space_tool.fie_man = Ui_Fieldsetting()
#         # self.work_space_tool.fie_man.setupUi(self.work_space_tool.FieldDialog,self.workingdirectory,self.pimplefoam_root,
#         #                                      model = self.model,turbulence_model = self.turbulence_model)
    
#     def update_dialog_by_model(self,model,turbulence_model,wall_function):
#         '''
#             实际作用为更新相关弹窗的湍流模型设置信息
#             model:laminar,RAS,LES
#             turbulence_model: e.g.kEpsilon,kOmegaSST
#             wall_function: on or off
#         '''
#         self.model = model
#         self.turbulence_model = turbulence_model
#         self.wall_function = wall_function

#         self.work_space_tool.FieldDialog = QDialog()
#         self.work_space_tool.fie_man = Ui_Fieldsetting()
#         self.work_space_tool.fie_man.setupUi(self.work_space_tool.FieldDialog,self.workingdirectory,self.pimplefoam_root,
#                                              model = self.model,turbulence_model = self.turbulence_model)

#         self.work_space_tool.SchemeDialog = QDialog()
#         self.work_space_tool.sch_man = Ui_Schemesetting()
#         self.work_space_tool.sch_man.setupUi(self.work_space_tool.SchemeDialog,self.workingdirectory,
#                                              model = self.model,turbulence_model = self.turbulence_model,
#                                              wall_function=self.wall_function)
       
#         self.work_space_tool.SolverDialog = QDialog()
#         self.work_space_tool.sol_man = Ui_Sol_Man()
#         self.work_space_tool.sol_man.setupUi(self.work_space_tool.SolverDialog,self.workingdirectory,
#                                              model = self.model,turbulence_model = self.turbulence_model)

    def activate(self, enable):
        """
        Activate/deactivate workspace.

        Arguments:
            enable (bool): *True* to activate, *False* to deactivate.
        """
        self.setVisible(enable)



    def detach(self, keep_pipeline=True):
        """
        Function called upon deactivating asterstudy, allows to properly
        remove all layouts and view from the ParaView View (salome View)
        """
        from .salomegui import get_salome_pyqt
        import pvsimple as pvs

        # Clears the PV widget and removes the event filter (right click
        # behavior) from all of its children.
        if self.pv_widget:
            for child in self.pv_widget_children:
                if child:
                    try:
                        child.removeEventFilter(self)
                    except BaseException: # pragma pylint: disable=broad-except
                        pass
            self.pv_widget_children = []
            self.pv_widget = None

        # This forces the creation of new overlay buttons upon restarting
        # the AsterStudy results tab
        self.pv_overlay = None
        self.toolbuttons = None

        # Deletes the active view and layout from paraview
        # Close the (salome) view corresponding to 'ParaView'
        if self.pv_view:
            get_salome_pyqt().closeView(self.pv_view)
        # get_salome_pyqt().closeView(self.ren_view)
        # get_salome_pyqt().closeView(self.ren_view1)
        
        # self.ren_view = None
        # self.ren_view1 = None
            pvs.RemoveLayout(self.pv_layout)
        self.pv_layout = None
        self.pv_view = None

        # Optional: clear all sources and proxies, leaving no trace!
        if not keep_pipeline:
            self.previous = {}
            self.current = None
            self.shown = None
            pxm = pvs.servermanager.ProxyManager()
            pxm.UnRegisterProxies()
            del pxm
            pvs.Disconnect()
            pvs.Connect()

    def init_paraview(self, full_load_pv=True):
        """
        Initializes, if necessary, paraview and creates a dedicated pvsimple
        view in the results tab.
        """
        from .salomegui import (get_salome_pyqt, get_salome_gui)

        if not self.pv_view:
            import time
            dbg_print(">> Initializing PV view for the main tab...")
            start = time.time()

            # A Paraview (view) already exists ?
            self.views = get_salome_pyqt().findViews('ParaView')
            
            # if not self.views:
            #     get_salome_pyqt().createView('ParaView', True, 0, 0, False)
            #     self.views = get_salome_pyqt().findViews('ParaView')
            #     print('111')
            self.pv_view = self.views[-1]
            get_salome_pyqt().activateViewManagerAndView(self.pv_view)
            paraview = self.update_pv_layout_view()
            end = time.time()
            dbg_print("  Finished in %d seconds..." % int(end - start))

            self._finalize_pv_widget()
        else:
            self.update_pv_layout_view()
            self._finalize_pv_widget()

        if self.current:
            self.redraw()
        # return paraview
    def _finalize_pv_widget(self):
        """
        References toolbuttons (for interactive selection) and updates the
        overlay widget if needed
        """
        if self.pv_widget:
            if not self.toolbuttons:
                self._add_toolbuttons()
            if not self.pv_overlay:
                self._add_overlay()

    def _add_toolbuttons(self):
        """
        Shortcut for referencing the toolbuttons that may need to be
        automatically activated for point and cell selections

        requires : self.pv_widget
        """
        self.toolbuttons = {'Interactive Select Cells On': None,
                            'Interactive Select Points On': None,
                            'Select Points On (d)': None,
                            'Select Cells On (s)': None,
                            }
        to_find = list(self.toolbuttons.keys())
        # Backward search since AsterStudy PV Layout is added after
        # the default one! ==>                              [::-1]
        for tbutt in self.pv_widget.findChildren(QtWidgets.QToolButton)[::-1]:
            if not to_find:
                break
            for tooltip in to_find:
                if tooltip in tbutt.toolTip():
                    self.toolbuttons[tooltip] = tbutt
                    to_find.remove(tooltip)
                    break

    def _add_overlay(self):
        """
        Add an overlay widget to the main pv_widget with a few buttons
        to control the view, save screenshots, etc.

        requires : self.pv_widget
        """

        # START
        # ol_height = 56 # Overlay height in pixels
        ol_height = 50  # Overlay height in pixels
        self.pv_overlay = OverlayBar(self.pv_widget, height=ol_height,
                                     color=(153,153,153), botline=(0, 0, 255, 2)
                                     )

        # >> Buttons toolbar items
        #    Start with an empty shell widget, used for parenting toolbar buttons
        #    and enforcing a simple horizontal layout with a right spacer
        hlayo = QtWidgets.QHBoxLayout()
        hlayo.setContentsMargins(5, 5, 5, 5)
        hlayo.setSpacing(5)
        # add_button(hlayo, tooltip='Refresh view',
        #            icon='PVC Refresh',
        #            callback=self.redraw)
        # add_separator(hlayo)

        # Camera controls
        add_button(hlayo, tooltip='Project view to X (YZ-plane)',
                   icon='PVC XProj',
                   callback=lambda: pvcontrol(self, 'xproj'))
        add_button(hlayo, tooltip='Project view to Y (XZ-plane)',
                   icon='PVC YProj',
                   callback=lambda: pvcontrol(self, 'yproj'))
        add_button(hlayo, tooltip='Project view to Z (XY-plane)',
                   icon='PVC ZProj',
                   callback=lambda: pvcontrol(self, 'zproj'))

        # Display controls
        self.outline_btn = add_button(hlayo, tooltip='Toggle bounding box',
                                      icon='PVC Outline',
                                      callback=lambda: pvcontrol(
                                          self, 'outline'),)
                                    #   checkable=True)

        # >> Information labels bar
        hlayo.addStretch(1)
        self.infobar_label = QtWidgets.QLabel(self.pv_overlay)
        hlayo.addWidget(self.infobar_label)
        self.update_infobar()

        self.pv_overlay.setLayout(hlayo)

    def update_pv_layout_view(self, full_update=True):
        """
        Updates or creates a new PV layout and view for AsterStudy
        post processing in the Results tab
        """
        import pvsimple as pvs
        from .salomegui import get_salome_pyqt

        pv_layout = pvs.GetLayoutByName(RESULTS_PV_LAYOUT_NAME)
        if not pv_layout:
            pv_layout = pvs.CreateLayout(name=RESULTS_PV_LAYOUT_NAME)

            
        self.views = pvs.GetViewsInLayout(pv_layout)
        if not self.views:
            pvs.SetActiveView(None)
            self.ren_view = pvs.CreateRenderView(guiName=RESULTS_PV_VIEW_NAME)

            self.ren_view.UseGradientBackground = 1
            pvs.GetRenderView().Background = [0.9,0.9,0.9]
            pvs.GetRenderView().Background2 = [0.6,0.6,0.6]
            pv_layout.AssignView(0, self.ren_view)

        self.pv_layout = pvs.GetLayoutByName("Layout #1")

        self.pv_widget = get_salome_pyqt().getViewWidget(self.pv_view)
        self.pv_widget.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                    QtWidgets.QSizePolicy.Expanding)

        self.pv_splitter.addWidget(self.pv_widget)

        self.pv_splitter.setVisible(False)
        self.pv_splitter.setVisible(True)

        pvs.Render()

        self.pv_widget_children = [self.pv_widget]
        self.pv_widget_children += self.pv_widget.findChildren(QtWidgets.QWidget)

        to_ignore = []
        if self.pv_overlay:
            to_ignore = [self.pv_overlay] + \
                self.pv_overlay.findChildren(QtWidgets.QWidget)

        for child in self.pv_widget_children:
            if not child in to_ignore:
                child.installEventFilter(self)


#     def clear_paraview_pipeline(self):
#         """
#         Clears up intermediate paraview pipeline sources and
#         refreshes the current representation
#         """
#         wait_cursor(True)
#         self.shown.clear_sources()
#         self.clear_readers()
#         self.redraw()
#         wait_cursor(False)

#     def clear_readers(self):
#         """
#         Clears readers from the paraview pipeline not relevant
#         to the current representation
#         """
#         import pvsimple as pvs

#         to_remove = []
#         for path in self.previous:
#             if path == self.current.path:
#                 continue
#             prev, _ = self.previous[path]

#             for source in ['filter_source', 'extract_source', 'source',
#                            'full_source', 'mode_source', 'dup_source']:
#                 if hasattr(prev, source):
#                     src = getattr(prev, source)
#                     setattr(prev, source, None)
#                     if not src:
#                         continue
#                     try:
#                         pvs.Delete(src)
#                     except RuntimeError:
#                         pass

#             to_remove.append(path)

#         for path in to_remove:
#             self.previous.pop(path, None)

#         for source in ['mode_source', 'dup_source']:
#             if hasattr(self.current, source):
#                 src = getattr(self.current, source)
#                 setattr(self.current, source, None)
#                 if not src:
#                     continue
#                 try:
#                     pvs.Delete(src)
#                 except RuntimeError:
#                     pass

#     def minmax_shown(self):
#         """Returns whether the minmax button is checked"""
#         return self.minmax_btn.isChecked()

#     def set_minmax_shown(self):
#         """Checks the minmax button"""
#         self.minmax_btn.setChecked(True)

#     def outline_shown(self):
#         """Returns whether the outline button is checked"""
#         return self.outline_btn.isChecked()

#     def set_outline_shown(self):
#         """Checks the outline button"""
#         self.outline_btn.setChecked(True)


#     def load_med_result(self, med_fn, loader):
#         """
#         Load a results file in MED format

#         Arguments:
#             med_fn (string): full path to the MED filename to be loaded
#             loader
#         """
#         if not med_fn:
#             dbg_print("Invalid med file")
#             return

#         self._loader = loader
#         self._loader.start()
#         QtCore.QTimer.singleShot(50, lambda: self.load_med_result_call(med_fn))

#     def load_med_result_call(self, med_fn, full_load_pv=True):
#         """
#         Load a results file in MED format

#         Arguments:
#             med_fn (string): full path to the MED filename to be loaded
#         """
#         # Initialize paraview widget in asterstudy gui
#         # (this can take a few seconds on first load)
#         new_load = True

#         self.init_paraview(full_load_pv=full_load_pv)
#         self.shown = None

#         modif_time = os.path.getmtime(med_fn)
#         if med_fn in self.previous:
#             # This file has already been read, check if the modification date
#             # is identifical to the previous load, if so then just set it as current
#             new_load = (modif_time != self.previous[med_fn][1])

#         if new_load:
#             if not self._loader:
#                 from . salomegui import LoadingMessage
#                 self._loader = LoadingMessage(self, 'Please wait...', True)
#                 self._loader.start()

#             res = ResultFile(med_fn)

#             # Check if there are indeed fields that can be represented
#             if res.is_empty():
#                 if self._loader:
#                     self._loader.terminate()
#                 wait_cursor(False)

#                 if self.astergui:
#                     msg = translate("AsterStudy",
#                                     "The provided MED file contains no "
#                                     "result concepts or fields.\n")
#                     buttons = QtWidgets.QMessageBox.Ok
#                     QtWidgets.QMessageBox.warning(self.astergui.mainWindow(), "AsterStudy",
#                                           msg, buttons, Qt.QMessageBox.Ok)

#                 return

#             self.current = res
#             self.previous.update({self.current.path: (self.current, modif_time)})
#         else:
#             self.current = self.previous[med_fn][0]

#         self.ren_view.ResetCamera()

#         # self.refresh_navigator()
#         pvcontrol(self, 'first')

#         # Show displacement field preferentially by default
#         for concept in self.current.concepts:
#             for field in concept.fields:
#                 if 'DEPL' in field.name:
#                     self.represent(field, WarpRep)
#                     pvcontrol(self, 'resetview')
#                     return

#         # If not found, show the first field that is found
#         for concept in self.current.concepts:
#             for field in concept.fields:
#                 self.represent(field)
#                 pvcontrol(self, 'resetview')
#                 return

#     def projection(self,ren_view,request):
#         if request == 'x':
#             refpos = [-1e5, 0., 0.]\
#                 if ren_view.CameraPosition[0] > 0\
#                 else [1e5, 0., 0.]
#             ren_view.CameraPosition = refpos
#             ren_view.CameraFocalPoint = [0.0, 0.0, 0.0]
#             ren_view.CameraViewUp = [0.0, 0.0, 1.0]
#             ren_view.ResetCamera()
#         elif request == 'y':
#             refpos = [0., -1e5, 0.] if ren_view.CameraPosition[1] > 0 else [0., 1e5, 0.]
#             ren_view.CameraPosition = refpos
#             ren_view.CameraFocalPoint = [0.0, 0.0, 0.0]
#             ren_view.CameraViewUp = [0.0, 0.0, 1.0]
#             ren_view.ResetCamera()
#         elif request == 'z':
#             refpos = [0., 0., 1e5] if ren_view.CameraPosition[2] < 0 \
#                 else [0., 0., -1e5]
#             ren_view.CameraPosition = refpos
#             ren_view.CameraFocalPoint = [0.0, 0.0, 0.0]
#             ren_view.CameraViewUp = [0.0, 1.0, 0.0]
#             ren_view.ResetCamera()        

#     def resetview(self,needreset):
#         if not needreset:
#             if self.sender() == self.sidebar.groupBox_5:
#                 pvs.HideAll(self.ren_view)
#                 pvs.Show(self.solidpvd, self.ren_view)
#                 self.currentdisplay = self.foamDisplay
#             elif self.sender() == self.sidebar.groupBox_6:
#                 pvs.HideAll(self.ren_view1)
#                 pvs.Show(self.fluidfoam, self.ren_view1)
#                 self.currentdisplay1 = self.fluidfoamDisplay

#     def cliping(self):
#         if self.sender() == self.sidebar.comboBox_9:
#             if not self.clip1:
#                 self.clip1 = pvs.Clip(Input=self.solidpvd)
#             pvs.Hide3DWidgets(proxy=self.clip1.ClipType)
#             if self.sender().currentText() == 'X方向':
#                 # self.clip1.ClipType.Origin = [-13184.847264041935, 0.0, 150000.0]
#                 self.clip1.ClipType.Normal = [1.0, 0.0, 0.0]
#             elif self.sender().currentText() == 'Y方向':
#                 # self.clip1.ClipType.Origin = [-13184.847264041935, 0.0, 150000.0]
#                 self.clip1.ClipType.Normal = [0.0, 1.0, 0.0]
#             elif self.sender().currentText() == 'Z方向':
#                 # self.clip1.ClipType.Origin = [-13184.847264041935, 0.0, 150000.0]
#                 self.clip1.ClipType.Normal = [0.0, 0.0, 1.0]

#             pvs.HideAll(self.ren_view)
#             clip1Display = pvs.Show(self.clip1, self.ren_view)
#             clip1Display.Representation = 'Surface'
#             self.currentdisplay = clip1Display

#         elif self.sender() == self.sidebar.comboBox_10:
#             if not self.clip2:
#                 self.clip2 = pvs.Clip(Input=self.fluidfoam)
#             pvs.Hide3DWidgets(proxy=self.clip2.ClipType)
#             if self.sender().currentText() == 'X方向':
#                 # self.clip1.ClipType.Origin = [-13184.847264041935, 0.0, 150000.0]
#                 self.clip2.ClipType.Normal = [1.0, 0.0, 0.0]
#             elif self.sender().currentText() == 'Y方向':
#                 # self.clip1.ClipType.Origin = [-13184.847264041935, 0.0, 150000.0]
#                 self.clip2.ClipType.Normal = [0.0, 1.0, 0.0]
#             elif self.sender().currentText() == 'Z方向':
#                 # self.clip1.ClipType.Origin = [-13184.847264041935, 0.0, 150000.0]
#                 self.clip2.ClipType.Normal = [0.0, 0.0, 1.0]

#             pvs.HideAll(self.ren_view1)
#             clip2Display = pvs.Show(self.clip2, self.ren_view1)
#             clip2Display.Representation = 'Surface'
#             self.currentdisplay1 = clip2Display

#         self.updateview()

#     def updateview(self):
#         # if self.sender() == self.sidebar.comboBox:
#             # HideUnusedScalarBars 方法来隐藏多余ScalarBars
#             pvs.HideUnusedScalarBars(self.ren_view)
#             self.currentdisplay.SetScalarBarVisibility(self.ren_view, True)
#             self.ren_view.Update()
#         # elif self.sender() == self.sidebar.comboBox_3:
#             # HideUnusedScalarBars 方法来隐藏多余ScalarBars
#             pvs.HideUnusedScalarBars(self.ren_view1)
#             self.currentdisplay1.SetScalarBarVisibility(self.ren_view1, True)
#             self.ren_view1.Update()

#             pvs.Render()

#     def renviewchange(self):
#         arrayname = self.sidebar.comboBox_5.currentText()
#         self.sidebar.comboBox_6.clear()
#         if arrayname in ['S','E']:
#             directs = ['Magnitude','xx','yy','zz','xy','yz','zx','Mises','Min Principal','Mid Principal','Max Principal',]
#         elif arrayname == 'U':
#             directs = ['Magnitude','D1','D2','D3']
#         else:
#             directs = []

#         for d in directs:
#             self.sidebar.comboBox_6.addItem(d)
#         # pvs.ColorBy(self.currentdisplay, ('POINTS', arrayname, 'Mises'))
#         pvs.ColorBy(self.currentdisplay, ('POINTS', arrayname))
#         self.colorobject[arrayname] = pvs.GetColorTransferFunction(arrayname)
#         # pvs.Render()
#         self.updateview()


#     def apply_params(self):
#         """
#         Called when the parameters are changed from the parameters
#         modification box (and the Apply button clicked)
#         """
#         rep = self.params.rep
#         if rep:
#             new_opts = self.params.values()
#             self.represent(rep.field, rep.__class__, False, **new_opts)

    def update_infobar(self):
        """
        Method used to update the information bar below the post-processing
        controls based on the shown field (uses self.shown)
        """
        info = ' '
        fsuffix = ''
        if self.shown:
            field, opts = self.shown.field, self.shown.opts
            comp = opts['Component'] if 'Component' in opts else ''
            if 'ColorField' in opts:
                cfield = opts['ColorField']
                if cfield != field:
                    fsuffix = ', colored by %s' % (
                        cfield.info['label'].split('(')[0])
                    if len(cfield.info['components']) > 1:
                        fsuffix += ' [%s]' % (comp)

            if not fsuffix:
                if len(field.info['components']) > 1:
                    fsuffix = ' [%s]' % (comp)

            ctime = self.ren_view.ViewTime
            # info = '<B>Concept :</B> %s; '\
            #        '<B>Field :</B> %s%s; '\
            #        '<B>Current time/frequency :</B> %g'\
            #        %(field.concept.name,
            #          field.info['label'], fsuffix, ctime)

            info = '<B><span style="color: #ffffff; background-color: #1d71b8;">'\
                   '&nbsp;Concept&nbsp;</B></span>&nbsp;%s'\
                   '&nbsp;<B><span style="color: #ffffff; background-color: #1d71b8;">'\
                   '&nbsp;Field&nbsp;</B></span>&nbsp;%s%s'\
                   '&nbsp;<B><span style="color: #ffffff; background-color: #1d71b8;">'\
                   '&nbsp;Time/Frequency&nbsp;</B></span>&nbsp;%g'\
                   % (field.concept.name,
                      field.name, fsuffix, ctime)

        if self.infobar_label:
            self.infobar_label.setText(info)

        # if self.mem_bar:
        #     current, available = get_pv_mem_use()
        #     self.mem_bar.setRange(0, int(available / 1024.))
        #     self.mem_bar.setValue(int(current / 1024.))

#     def redraw(self):
#         """
#         Redraws the current field
#         """
#         pvs.GetActiveView().ResetCamera()
        

#     # pragma pylint: disable=invalid-name
#     def eventFilter(self, source, event):
#         """
#         EventFilter for capturing mouse clicks over the ParaView
#         widget.
#         """
#         if not hasattr(self, 'pv_widget_children'):
#             return 0

#         if source in self.pv_widget_children:
#             #定义了在paraview视窗中双击右击操作对应的事件
#             # pass
#             if event.type() == QtCore.QEvent.MouseButtonPress:
#                 # self.on_click_callback()
#                 if hasattr(event, 'button'):
#                     return 1
#             elif event.type() == QtCore.QEvent.MouseButtonRelease:
#                 self.on_click_callback()
#                 if hasattr(event, 'button'):
#                     if event.button() == QtCore.Qt.RightButton:
#                         # self.navtree.contextMenuEvent('Representation')
#                         pass
#                     return 1
#             # elif event.type() == Qt.QEvent.MouseButtonDblClick:
#             #     pvcontrol(self, 'clear_selection')
#             #     return 1

#         return QtWidgets.QWidget.eventFilter(self, source, event)

#     def on_click_callback(self):
#         """
#         Callback to launch either a probing or plot operation based
#         on the user selection
#         """
#         if not self.shown:
#             return

#         if not self.shown.pickable:
#             return

#         selection, _, _ = get_active_selection(self.shown.source)
#         if selection:
#             self.probe_plot_callback()
#         else:
#             QtCore.QTimer.singleShot(100, self.probe_plot_callback)

#     def probe_plot_callback(self):
#         """
#         Delayed probe as to allow selection to be coined
#         """
#         selection, _, _ = get_active_selection(self.shown.source)
#         if selection:
#             if self.probing:
#                 selection_probe(self)
#             else:
#                 selection_plot(self)
#                 self.probing = True

#     def plot(self, data, variable):
#         """
#         Adds a popup dialog with a plot of the given data
#         """
#         dialog = QtWidgets.QDialog(self)
#         dialog.ui = PlotWindow(data=data, variable=variable)
#         dialog.ui.setWindowTitle('AsterStudy - Selection plot over time')
#         dialog.ui.show()


def add_button(layout, name='', tooltip='', icon=None,
               callback=None, checkable=False):
    """
    Adds a push button to the given parent widget and layout with some
    user-defined properties
    """
    from . import get_icon
    button = QtWidgets.QPushButton(name)
    button.setFixedWidth(100)
    if tooltip:
        button.setToolTip(tooltip)
    if icon:
        button.setIcon(get_icon(icon))
    button.setCheckable(checkable)
    if checkable:
        button.toggled.connect(callback)
    else:
        button.clicked.connect(callback)

    layout.addWidget(button)
    return button


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    aaa = QMainWindow()
    main = Workspace()
    main.setupUi(aaa)
    aaa.show()
    sys.exit(app.exec_())
